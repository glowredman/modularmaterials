package glowredman.modularmaterials.util;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;

import glowredman.modularmaterials.Main;
import glowredman.modularmaterials.Reference;
import glowredman.modularmaterials.object.Material;
import glowredman.modularmaterials.object.Type;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class AssetHandler {
	
	public static List<String> itemTextures = new ArrayList<String>();
	
	public static void initItemTextureList() {
		int textureCount = 0;
		long time = System.currentTimeMillis();
		
		Iterator i = MaterialHandler.getIterator(Reference.materials);
		while(i.hasNext()) {
			Entry<String, Material> e = (Entry<String, Material>) i.next();
			String texture = e.getValue().getTexture();
			if(!itemTextures.contains(texture)) {
				itemTextures.add(texture);
				textureCount++;
			}
		}
		Main.logger.info("Detected " + textureCount + " different meta-item-textures-sets in " + (System.currentTimeMillis() - time) + "ms.");
	}
	
	@SideOnly(Side.CLIENT)
	public static void createModelFiles() {
		long time = System.currentTimeMillis();
		int modelFileCount = 0;
		
		//iterate through all materials
		for(Material material : Reference.materials.values()) {
			String texture = material.getTexture();
			
			//check if the material should even be registered
			if(material.isDisabled() && !Reference.enableAll) {
				continue;
			} else {
				
				//iterate through all of the materials types
				Iterator types = MaterialHandler.getIterator(material.getEnabledTypes());
				while(types.hasNext()) {
					Entry<String, Boolean> typeEntry = (Entry<String, Boolean>) types.next();
					String type = typeEntry.getKey();
					
					//check, if there should be an item of this type and material
					boolean b = false;
					try {
						b = (typeEntry.getValue().equals(true)  && Reference.types.get(type).getCategory().equals("item") && !Reference.types.get(type).isDisabled()) || Reference.enableAll ? true : false;
					} catch (Exception e) {
						if(!Reference.suppressTypeMissingWarnings) {
							Main.logger.error(Reference.CONFIGNAME_TYPES + " does not contain information for the type \"" + type + "\"! Add \"" + type + "\" to " + Reference.CONFIGNAME_TYPES + " or enable 'suppressMissingTypeWarnings' in " + Reference.CONFIGNAME_CORE + '.');
						}
					}
					if(b) {
						File dir = new File(Minecraft.getMinecraft().mcDataDir + "/resources/" + Reference.MODID + "/models/item/" + texture);
						File file = new File(dir, type + ".json");
						try {
							dir.mkdirs();
							
							//if the file does not already exist or should be overridden, create it
							if(!file.exists() || Reference.overrideModelFiles) {
								if(file.exists()) {
									file.delete();
								}
								BufferedWriter writer = new BufferedWriter(new FileWriter(file));
								writer.write("{");
								writer.newLine();
								writer.write("\t\"parent\": \"item/generated\",");
								writer.newLine();
								writer.write("\t\"textures\": {");
								writer.newLine();
								writer.write("\t\t\"layer0\": \"" + Reference.MODID + ":items/" + texture + "/" + type + "\",");
								writer.newLine();
								writer.write("\t\t\"layer1\": \"" + Reference.MODID + ":items/" + texture + "/" + type + "_overlay\"");
								writer.newLine();
								writer.write("\t}");
								writer.newLine();
								writer.write("}");
								writer.close();
								modelFileCount++;
							}
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
			}
		}
		
		//TODO blocks
		
		//TODO fluids
		
		Main.logger.info("Created " + modelFileCount + " model-files in " + (System.currentTimeMillis() - time) + "ms.");
	}
	
	@SideOnly(Side.CLIENT)
	public static void createLangFile() {
		long time = System.currentTimeMillis();
		int lineCount = 0;
		File dir = new File(Minecraft.getMinecraft().mcDataDir + "/resources/" + Reference.MODID + "/lang/");
		File file = new File(dir, "en_us.lang");
		
		if(!file.exists() || Reference.overrideLangFile) {
			if(file.exists()) {
				file.delete();
			}
			try {
				dir.mkdirs();
				
				BufferedWriter writer = new BufferedWriter(new FileWriter(file));
				
				//header
				writer.write("# automaticly generated by " + Reference.MODNAME);
				writer.newLine();
				writer.newLine();
				writer.write("item." + Reference.MODID + ".debug.name=Â§cInvalid Item");
				lineCount++;
				writer.newLine();
				
				Iterator i = MaterialHandler.getIterator(Reference.types);
				while(i.hasNext()) {
					Entry<String, Type> e = (Entry<String, Type>) i.next();
					String type = e.getKey();
					String syntax = e.getValue().getSyntax();
					
					newParagraph(writer);
					
					Iterator j = MaterialHandler.getIterator(Reference.materials);
					while(j.hasNext()) {
						Entry<String, Material> f = (Entry<String, Material>) j.next();
						String unlocalizedName = f.getValue().getUnlocalizedName();
						String name = f.getValue().getName();
						writer.write("item." + Reference.MODID + '.' +  type + '.' + unlocalizedName + ".name=" + syntax.replace("%s", name));
						writer.newLine();
						lineCount++;
					}
				}
				
				
				writer.close();
				Main.logger.info("Created " + lineCount + " localizations in " + (System.currentTimeMillis() - time) + "ms.");
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	
	static void newParagraph(BufferedWriter writer) throws IOException {
		writer.newLine();
		writer.newLine();
		writer.newLine();
		
	}

}
